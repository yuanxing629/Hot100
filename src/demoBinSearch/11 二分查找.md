# 35 搜索插入位置

**简单题**

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 `O(log n)` 的算法。

**示例 1:**

```
输入: nums = [1,3,5,6], target = 5
输出: 2
```

**示例 2:**

```
输入: nums = [1,3,5,6], target = 2
输出: 1
```

**示例 3:**

```
输入: nums = [1,3,5,6], target = 7
输出: 4
```

## 法一 二分查找

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int n = nums.length;
        if (target > nums[n - 1]) {
            return n;
        }
        if (target <= nums[0]) {
            return 0;
        }
        int left = 0, right = n - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return left;
    }
}
```

# 74 搜索二维矩阵

**中等题**

给你一个满足下述两条属性的 `m x n` 整数矩阵：

- 每行中的整数从左到右按非严格递增顺序排列。
- 每行的第一个整数大于前一行的最后一个整数。

给你一个整数 `target` ，如果 `target` 在矩阵中，返回 `true` ；否则，返回 `false` 。

## 法一 二分查找

时间复杂度为 $O(\log (mn))$ 

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m = matrix.length, n = matrix[0].length;
        int low = 0, high = m * n - 1;
        while (low <= high) {
            int mid = low + (high - low) / 2;
            int num = matrix[mid / n][mid % n];
            if (target == num) {
                return true;
            } else if (target > num) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return false;
    }
}
```

## 法二 Z字查找

时间复杂度为 $O(m+n)$ 

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        // 从左下角开始找。（右上角也可以）
        int m = matrix.length, n = matrix[0].length;
        int i = m - 1, j = 0;
        while (i >= 0 && i < m && j >= 0 && j < n) {
            int num = matrix[i][j];
            if (num == target) {
                return true;
            } else if (num > target) {
                i--;
            } else {
                j++;
            }
        }
        return false;
    }
}
```

# [34 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array)

**中等题**

给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 `target`，返回 `[-1, -1]`。

你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。

**示例 1：**

```
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```

**示例 2：**

```
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
```

**示例 3：**

```
输入：nums = [], target = 0
输出：[-1,-1]
```

**分析：**

先二分查找找到目标值的一个索引，再**左右滑动指针**，从而找到最左和最右索引。

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        // 先通过二分查找得到目标值的一个索引，再左右滑动指针
        // 从而找到最左和最右索引
        int index = binarySearch(nums, target);

        // 如果nums中不存在target，直接返回{-1,-1}
        if (index == -1) {
            return new int[]{-1, -1};
        }

        int left = index, right = index;
        while (left - 1 >= 0 && nums[left - 1] == target) {
            left--;
        }
        while (right + 1 < nums.length && nums[right + 1] == target) {
            right++;
        }

        return new int[]{left, right};
    }

    /**
     * 二分查找
     */
    public int binarySearch(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return -1; // 不存在返回-1
    }
}
```

# 33 搜索旋转排序数组

**中等题**

整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。

在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **向左旋转**，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如， `[0,1,2,4,5,6,7]` 下标 `3` 上向左旋转后可能变为 `[4,5,6,7,0,1,2]` 。

给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

**示例 1：**

```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

**示例 2：**

```
输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
```

**示例 3：**

```
输入：nums = [1], target = 0
输出：-1
```

------

**分析：**

- 数组原本是有序的，经过向左旋转，得到了两个有序数组。
- 虽然下标 `k` 是预先未知的，但只需要遍历数组找到满足 `nums[i] > nums[i+1]` 的那个 `i` ，就可以找到原数组和新数组索引的对应关系。

## 法一

```java
class Solution {
    public int search(int[] nums, int target) {
        int n = nums.length;
        int i = 0;
        while (i < n - 1) {
            if (nums[i] > nums[i + 1]) {
                // i 会停留在数组中的最大元素位置
                // 如果 k 为 0，即数组没有被旋转，i 会停在 n - 1
                break;
            }
            i++;
        }

        // 记录最大元素的位置
        int largest = i;
        // 如果数组没有被旋转过，直接进行二分查找
        if (i == n - 1) {
            return binarySearch(nums, target);
        }

        // original即原来的数组
        int[] temp = new int[n];
        int k = 0;
        while (i < n - 1) {
            temp[k++] = nums[++i];
        }
        i = 0;
        while (i <= largest) {
            temp[k++] = nums[i++];
        }

        // 在原数组上进行二分查找
        int res = binarySearch(temp, target);
        return res == -1 ? res : (res + largest + 1) % n;
    }

    public int binarySearch(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return -1; // 不存在返回-1
    }
}
```

## 法二 官方

```java
class Solution {
    public int search(int[] nums, int target) {
        int n = nums.length;
        if (n == 0) {
            return -1;
        }
        if (n == 1) {
            return nums[0] == target ? 0 : -1;
        }
        int l = 0, r = n - 1;
        while (l <= r) {
            int mid = (l + r) / 2;
            if (nums[mid] == target) {
                return mid;
            }
            if (nums[0] <= nums[mid]) {
                if (nums[0] <= target && target < nums[mid]) {
                    r = mid - 1;
                } else {
                    l = mid + 1;
                }
            } else {
                if (nums[mid] < target && target <= nums[n - 1]) {
                    l = mid + 1;
                } else {
                    r = mid - 1;
                }
            }
        }
        return -1;
    }
}
```

# [153 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array)

已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：

- 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]`
- 若旋转 `7` 次，则可以得到 `[0,1,2,4,5,6,7]`

注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。

给你一个元素值 **互不相同** 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

**示例 1：**

```
输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。
```

**示例 2：**

```
输入：nums = [4,5,6,7,0,1,2]
输出：0
解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。
```

**示例 3：**

```
输入：nums = [11,13,15,17]
输出：11
解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。
```

## 法一

```java
class Solution {
    /**
        时间复杂度为O(n)    
    */
    public int findMin(int[] nums) {
        int n = nums.length;
        int i = 0;
        while (i < n - 1) {
            if (nums[i] > nums[i + 1]) {
                break;
            }
            i++;
        }

        return i == n - 1 ? nums[0] : nums[i + 1];
    }
}
```

## 法二 二分查找

分析：

我们考虑数组中最后一个元素 $x$ ：在最小值右侧的元素（不包括最后一个元素本身），它们的值一定严格小于 $x$ ；而在最小值左侧的元素，它们的值都一定严格大于 $x$ 。于是可以用二分查找找到最小值。

<img src="./11 二分查找.assets/image-20260206150954877.png" alt="image-20260206150954877" />

我们每次将 $nums[pivot]$ 和 $nums[high]$ 进行比较，有三种情况：

- $nums[pivot] < nums[high]$ ：说明 $nums[pivot]$ 是最小值右侧的元素，可以忽略二分查找区间的右半部分：`high = pivot;` 
- $nums[pivot] > nums[high]$：说明 $nums[pivot]$ 是最小值左侧的元素，可以忽略二分查找区间的左半部分：`low = pivot + 1;`
- 由于数组不包含重复元素，并且只要当前的区间长度不为1，pivot就不会与high重合；而如果当区间长度为1，说明我们可以结束二分查找了。因此不会存在 $nums[pivot] = nums[high]$ 的情况。

```java
class Solution {
    public int findMin(int[] nums) {
        int low = 0;
        int high = nums.length - 1;
        while (low < high) {
            int pivot = low + (high - low) / 2;
            if (nums[pivot] < nums[high]) {
                high = pivot;
            } else {
                low = pivot + 1;
            }
        }
        return nums[low];
    }
}
```

